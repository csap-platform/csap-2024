  #!/bin/bash
  
  source $CSAP_FOLDER/bin/csap-environment.sh
  
  #
  #   References:
  #   - docker options: docker-dev-artifactory.yourcompany.com/csapplatform/fio
  #   - scenarios: https://fio.readthedocs.io/en/latest/fio_doc.html
  #
  #   Invokation NOtes
  #   if invoked from csap-job-run.sh will source csap-environment.sh, which includes all the helper functions and service variables
  #   - ref: $CSAP_FOLDER/bin/csap-environment.sh
  #   - ref: https://github.com/csap-platform/csap-core/wiki/Service-Definition#runtime-variables
  #
  
  print_section "Service Runner: $csapName"
  
  
  
  function setup() {
  
    # fio ouput parsed with jq
    install_if_needed jq ; 
    install_if_needed bc ; 
    
    # print_command "environment variables" "$(env)"
    
  	testProfile=${testProfile:-randomReadWrite} ;
    print_two_columns "testProfile" "$testProfile"
    
  	readPercent=${readPercent:-70} ;
    print_two_columns "readPercent" "$readPercent"
    
  	ioDepth=${ioDepth:-16} ;
    print_two_columns "ioDepth" "$ioDepth"
    
    
  	export timeToRunInSeconds=${timeToRunInSeconds:-120} ;
    print_two_columns "timeToRunInSeconds" "$timeToRunInSeconds"
    
  
  	blockSizesInKb=${blockSizesInKb:-4 8 16} ;
    print_two_columns "blockSizesInKb" "$blockSizesInKb"
    
  	testSizeInG=${testSizeInG:-1} ;
    print_two_columns "testSizeInG" "$testSizeInG"
    
  	threadIterations=${threadIterations:-1 2 4 } ;
    print_two_columns "threadIterations" "$threadIterations"
   
  
    fioImage=${fioImage:-default} ;
    if [[ "$fioImage" == "default" ]] ; then
      fioImage="csapplatform/fio:latest"
      if [[ "$(hostname --long)" == *hostx.yourcompany ]] ; then fioImage="docker-dev-artifactory.yourcompany.com/csapplatform/fio:latest" ; fi
    fi ;
    print_two_columns "fioImage" "$fioImage"
    
    
    reportsFolder="$csapLogDir/reports" ;
    if ! test -d reportsFolder ; then
      print_two_columns "reportsFolder" "$(mkdir --verbose --parents $reportsFolder)"
    fi ;
    
    latestLogFile="$reportsFolder/fio-latest.log" ;
    print_two_columns "latestLogFile" "$latestLogFile"
    backup_file $latestLogFile
    
  
    wordPadding=12 ;
    
    local verbose=false ;
    append_file "# generated by fio-tester.sh" $latestLogFile $verbose
    
    
  }
  
  
  setup ;
  
  
  
  function run_fio() {
    
    local containerName="$1"
    local blockSizeInKb="$2"
    local fioParameters="$3"
    
    local startSeconds=$(date +%s) ;
    
    local dockerParameters="run --name=$containerName --rm=true" ;
    
    run_using_root "echo -e '\nMemory Before:' && free -h && sync && echo 3 > /proc/sys/vm/drop_caches && echo -e '\n\nMemory After:' && free -h "
    
    print_command "docker command" "$(echo "docker $dockerParameters \\"; echo "  $fioImage  \\"; echo "  $fioParameters" )"
    
    #print_separator "START: $args output"
    print_two_columns "fioParameters" "$fioParameters" ;
    print_two_columns "Starting fio" "output is being captured and will be printed after completion" ;
    local fioReport=$(docker $dockerParameters --env parameters="$fioParameters" $fioImage)
  
    print_command "report completed" "$fioReport"
    
    local fioJsonOutput=$(trimmed_text "$fioReport") ;
    # print_command "fioJsonOutput" "$fioJsonOutput"
    
    local ms=$(echo $fioJsonOutput | jq '.jobs[0].job_runtime')
    local timeInSeconds=$(echo "scale=1;$ms/1000" | bc --mathlib) ; # $(bc <<< $ms/1000) ;
    
    
    local totalDiskInGb=$testSizeInG ;
    
    local jobCount=$(echo $fioJsonOutput | jq '.jobs[0]."job options".numjobs | tonumber') ;
    local threads=$jobCount ;
    
    
    local diskReadIos=$(echo $fioJsonOutput | jq '.disk_util[0].read_ios') ;
    local diskWriteIos=$(echo $fioJsonOutput | jq '.disk_util[0].write_ios') ;
    
  
    
    local jobId=".jobs[]" ;
      
    local readIops=$(echo $fioJsonOutput | jq "[ $jobId.read.iops ] | add") ;
    readIops=$(echo "scale=0;$readIops/1" | bc --mathlib) ;
    local readBw=$(echo $fioJsonOutput | jq "[ $jobId.read.bw ] | add") ;

    # aws linux has older jq - missing round
#    local readLatencyMs=$(echo $fioJsonOutput | jq "[ $jobId.read.lat_ns.mean ] | add / length / 1000000 | round") ;
    local readLatencyMs=$(echo $fioJsonOutput | jq "def round: . + 0.5 | floor;[ $jobId.read.lat_ns.mean ] | add / length / 1000000 | round") ;
    
    local writeIops=$(echo $fioJsonOutput | jq "[ $jobId.write.iops ] | add") ;
    writeIops=$(echo "scale=0;$writeIops/1" | bc --mathlib) ;
    local writeBw=$(echo $fioJsonOutput | jq "[ $jobId.write.bw ] | add") ;
    local writeLatencyMs=$(echo $fioJsonOutput | jq "def round: . + 0.5 | floor;[ $jobId.write.lat_ns.mean ] | add / length / 1000000 | round") ;
    
    # local readIops=$(echo $fioJsonOutput | jq "$jobId.read.iops") ;
    # local readBw=$(echo $fioJsonOutput | jq "$jobId.read.bw") ;
    
    # local writeIops=$(echo $fioJsonOutput | jq "$jobId.write.iops") ;
    # local writeBw=$(echo $fioJsonOutput | jq "$jobId.write.bw") ;
    
    local endSeconds=$(date +%s) ;
    local osTimeInSeconds=$(( $endSeconds - $startSeconds ));
    
    local reportLine=$(formatLine $wordPadding "$threads $blockSizeInKb $readIops $readBw $readLatencyMs $writeIops $writeBw $writeLatencyMs $diskReadIos $diskWriteIos $osTimeInSeconds $totalDiskInGb") 
    print_two_columns "extracted data" "$reportLine"
    
    print_two_columns "time taken" "real $osTimeInSeconds seconds, fio $timeInSeconds seconds"
  
    append_line "$reportLine"
    
    
  }
  
  function printReportHeader() {
    
    local testLabel="$*"
    
    append_line ""
    append_line ""
    append_line "#"
    append_line "# test: $testLabel"
    append_line "#"
    local headerLine=$(formatLine $wordPadding "threads blockSizeKb readIops readBwMbPerS readMs writeIops writeBwMbPs writeMs diskReadIos diskWriteIos timeInSec totalDiskGb")
    append_line "$headerLine"
    
  }
  
  #
  # randrw, readwrite(sequential), read, write, randread, randwrite
  #
  function randomReadWrite() {
    
  	print_section "randomReadWrite"
  	
  	printReportHeader "randomReadWrite"
    
  	testContainerName="$csapName" ;
  
  # 	local sysBenchOltp="/usr/share/sysbench/tests/include/oltp_legacy/oltp.lua run" ;
  
    local threadCount
    local fioParameters
    
  
    
    for threadCount in $threadIterations ; do
    
      for blockSize in $blockSizesInKb ; do
    	  fioParameters="--name=random-read-write --time_based --runtime=$timeToRunInSeconds"
    	  fioParameters="$fioParameters --bs=${blockSize}k --size=${testSizeInG}g  --rw=randrw --rwmixread=$readPercent"
    	  fioParameters="$fioParameters --ioengine=posixaio  --numjobs=$threadCount  --iodepth=$ioDepth  --end_fsync=1" ;
    	  fioParameters="$fioParameters --output-format=json" ;
    	  
    	  
    	  run_fio "$testContainerName" "$blockSize" "$fioParameters" ;
    	  
        delay_with_message 60 "Spacing reports to ensure collection result captured"
      
      done ;
    done ;
    
    delay_with_message 120 "Run Completed - Final Spacing delay"
    
    
    
    
    print_with_date "Test Completed"
  }
  
  function perfSuite() {
    
    local fio_test_types="read randread write randwrite randrw"
    local fio_max_time_limit=300
    
  	# Set to 1 to use non-buffered IO, 0 to use buffered IO
  	# Default: 1
  	fio_direct_io=1
    
  	print_section "Test Suite"
    
  	testContainerName="$csapName" ;
  
  # 	local sysBenchOltp="/usr/share/sysbench/tests/include/oltp_legacy/oltp.lua run" ;
  
    local threadCount
    local fioParameters
    
    
    for blockSize in $blockSizesInKb ; do
      
      for fioTest in $fio_test_types ; do
      
        printReportHeader "fio mode: $fioTest  blockSize: ${blockSize}k"
      
        for threadCount in $threadIterations ; do
      
      	  fioParameters="--name=random-read-write --runtime=$(( $timeToRunInSeconds*1  ))"
      	  fioParameters="$fioParameters --bs=${blockSize}k --size=$(( $testSizeInG*1  ))g --rw=$fioTest --direct=$fio_direct_io"
      	  
      	  if [[ "$fioTest" == "randrw" ]] ; then
      	    fioParameters="$fioParameters --rwmixread=$readPercent"
      	  fi
      	  
      	  fioParameters="$fioParameters --ioengine=posixaio  --numjobs=$threadCount  --iodepth=$ioDepth  --end_fsync=1" ;
      	  fioParameters="$fioParameters --output-format=json" ;
      	  
      	  
      	  run_fio "$testContainerName" "$blockSize" "$fioParameters" ;
      	  
          delay_with_message $(( $timeToRunInSeconds/2  )) "Spacing reports to ensure collection result captured"
        
        done ;
      done ;
    done ;
    
    delay_with_message $(( $timeToRunInSeconds/2  )) "Run Completed - Final Spacing delay"
    
    
    
    
  }
  
  # /usr/share/sysbench/tests/include/oltp_legacy/csap-oltp.lua
  
  function perform_operation() {
    
    
    local startSeconds=$(date +%s) ;
  
  	case "$testProfile" in
  		
  		"randomReadWrite" | "default")
  			randomReadWrite
  			perfSuite
  			;;
  		
  		 *)
  	            echo "Command Not found"
  	            exit 1
  	esac
  	
  	
    latestCsvFile="$reportsFolder/fio-latest.csv" ;
    print_two_columns "latestCsvFile" "$latestCsvFile"
    backup_file $latestCsvFile
    
    cat $latestLogFile | awk '{$1=$1};1' | sed 's/  */,/g' > $latestCsvFile
    
    
    local endSeconds=$(date +%s) ;
    
    print_with_date "Test Completed: $(( ( $endSeconds - $startSeconds) / 60   )) minutes"
  
  }
  
  perform_operation